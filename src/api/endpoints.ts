/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * ClassMate backend
 * ClasssMate backend
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import type {
  AutosolveRequest,
  AutosolveResponse,
  Chat,
  ChatMessageContent,
  CreateAutosolveChat200,
  CreateAutosolveChatBody,
  CreateChatBody,
  CreateChatParams,
  CreateSubscription200,
  CreateSubscriptionBody,
  GetNotesParams,
  ManageSubscription200,
  Note,
  NoteEdit,
  PauseSubscriptionBody,
  Referral,
  Subscription,
  Tag,
  TagBase,
} from './model';

/**
 * Create a new chat
 * @summary Create a new chat
 */
export const createChat = (
  createChatBody: CreateChatBody,
  params?: CreateChatParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Chat>> => {
  return axios.post(`/chats`, createChatBody, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getCreateChatMutationOptions = <
  TData = Awaited<ReturnType<typeof createChat>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateChatBody; params?: CreateChatParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['createChat'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createChat>>,
    { data: CreateChatBody; params?: CreateChatParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return createChat(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateChatBody; params?: CreateChatParams },
    TContext
  >;
};

export type CreateChatMutationResult = NonNullable<
  Awaited<ReturnType<typeof createChat>>
>;
export type CreateChatMutationBody = CreateChatBody;
export type CreateChatMutationError = AxiosError<unknown>;

/**
 * @summary Create a new chat
 */
export const useCreateChat = <
  TData = Awaited<ReturnType<typeof createChat>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateChatBody; params?: CreateChatParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { data: CreateChatBody; params?: CreateChatParams },
  TContext
> => {
  const mutationOptions = getCreateChatMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get a chat
 * @summary Get a chat
 */
export const getChat = (
  chatId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Chat>> => {
  return axios.get(`/chats/${chatId}`, options);
};

export const getGetChatQueryKey = (chatId: string) => {
  return [`/chats/${chatId}`] as const;
};

export const getGetChatQueryOptions = <
  TData = Awaited<ReturnType<typeof getChat>>,
  TError = AxiosError<void>,
>(
  chatId: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getChat>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChatQueryKey(chatId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChat>>> = ({
    signal,
  }) => getChat(chatId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!chatId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getChat>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetChatQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChat>>
>;
export type GetChatQueryError = AxiosError<void>;

/**
 * @summary Get a chat
 */

export function useGetChat<
  TData = Awaited<ReturnType<typeof getChat>>,
  TError = AxiosError<void>,
>(
  chatId: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getChat>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChatQueryOptions(chatId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Send a user message. Response will be streamed in real time as plain text.

 * @summary Send message
 */
export const sendMessage = (
  chatId: string,
  chatMessageContent: ChatMessageContent,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string>> => {
  return axios.put(`/chats/${chatId}`, chatMessageContent, options);
};

export const getSendMessageMutationOptions = <
  TData = Awaited<ReturnType<typeof sendMessage>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { chatId: string; data: ChatMessageContent },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['sendMessage'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendMessage>>,
    { chatId: string; data: ChatMessageContent }
  > = (props) => {
    const { chatId, data } = props ?? {};

    return sendMessage(chatId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { chatId: string; data: ChatMessageContent },
    TContext
  >;
};

export type SendMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendMessage>>
>;
export type SendMessageMutationBody = ChatMessageContent;
export type SendMessageMutationError = AxiosError<unknown>;

/**
 * @summary Send message
 */
export const useSendMessage = <
  TData = Awaited<ReturnType<typeof sendMessage>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { chatId: string; data: ChatMessageContent },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { chatId: string; data: ChatMessageContent },
  TContext
> => {
  const mutationOptions = getSendMessageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create a new autosolve chat. The chat will be created with a system message that will
prompt the model to solve the problem and with an user message that will insert the context
of the problem.

 * @summary Create a new autosolve chat
 */
export const createAutosolveChat = (
  createAutosolveChatBody: CreateAutosolveChatBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<CreateAutosolveChat200>> => {
  return axios.post(`/chats/autosolve`, createAutosolveChatBody, options);
};

export const getCreateAutosolveChatMutationOptions = <
  TData = Awaited<ReturnType<typeof createAutosolveChat>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateAutosolveChatBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['createAutosolveChat'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAutosolveChat>>,
    { data: CreateAutosolveChatBody }
  > = (props) => {
    const { data } = props ?? {};

    return createAutosolveChat(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateAutosolveChatBody },
    TContext
  >;
};

export type CreateAutosolveChatMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAutosolveChat>>
>;
export type CreateAutosolveChatMutationBody = CreateAutosolveChatBody;
export type CreateAutosolveChatMutationError = AxiosError<unknown>;

/**
 * @summary Create a new autosolve chat
 */
export const useCreateAutosolveChat = <
  TData = Awaited<ReturnType<typeof createAutosolveChat>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateAutosolveChatBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { data: CreateAutosolveChatBody },
  TContext
> => {
  const mutationOptions = getCreateAutosolveChatMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Solves the provided problem.
 * @summary Autosolve
 */
export const autosolve = (
  autosolveRequest: AutosolveRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<AutosolveResponse>> => {
  return axios.post(`/autosolve`, autosolveRequest, options);
};

export const getAutosolveMutationOptions = <
  TData = Awaited<ReturnType<typeof autosolve>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: AutosolveRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['autosolve'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof autosolve>>,
    { data: AutosolveRequest }
  > = (props) => {
    const { data } = props ?? {};

    return autosolve(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: AutosolveRequest },
    TContext
  >;
};

export type AutosolveMutationResult = NonNullable<
  Awaited<ReturnType<typeof autosolve>>
>;
export type AutosolveMutationBody = AutosolveRequest;
export type AutosolveMutationError = AxiosError<void>;

/**
 * @summary Autosolve
 */
export const useAutosolve = <
  TData = Awaited<ReturnType<typeof autosolve>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: AutosolveRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, { data: AutosolveRequest }, TContext> => {
  const mutationOptions = getAutosolveMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create a new subscription
 * @summary Create a new subscription
 */
export const createSubscription = (
  createSubscriptionBody: CreateSubscriptionBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<CreateSubscription200>> => {
  return axios.post(`/subscription/new`, createSubscriptionBody, options);
};

export const getCreateSubscriptionMutationOptions = <
  TData = Awaited<ReturnType<typeof createSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateSubscriptionBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['createSubscription'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSubscription>>,
    { data: CreateSubscriptionBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSubscription(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateSubscriptionBody },
    TContext
  >;
};

export type CreateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSubscription>>
>;
export type CreateSubscriptionMutationBody = CreateSubscriptionBody;
export type CreateSubscriptionMutationError = AxiosError<void>;

/**
 * @summary Create a new subscription
 */
export const useCreateSubscription = <
  TData = Awaited<ReturnType<typeof createSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: CreateSubscriptionBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { data: CreateSubscriptionBody },
  TContext
> => {
  const mutationOptions = getCreateSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Manage a subscription and payment info.
 * @summary Manage a subscription
 */
export const manageSubscription = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ManageSubscription200>> => {
  return axios.post(`/subscription/manage`, undefined, options);
};

export const getManageSubscriptionMutationOptions = <
  TData = Awaited<ReturnType<typeof manageSubscription>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['manageSubscription'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof manageSubscription>>,
    void
  > = () => {
    return manageSubscription(axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    void,
    TContext
  >;
};

export type ManageSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof manageSubscription>>
>;

export type ManageSubscriptionMutationError = AxiosError<unknown>;

/**
 * @summary Manage a subscription
 */
export const useManageSubscription = <
  TData = Awaited<ReturnType<typeof manageSubscription>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getManageSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Pause a subscription. Subscription can be paused only if it's active or past_due.

 * @summary Pause a subscription
 */
export const pauseSubscription = (
  pauseSubscriptionBody: PauseSubscriptionBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`/subscription/pause`, pauseSubscriptionBody, options);
};

export const getPauseSubscriptionMutationOptions = <
  TData = Awaited<ReturnType<typeof pauseSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: PauseSubscriptionBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['pauseSubscription'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pauseSubscription>>,
    { data: PauseSubscriptionBody }
  > = (props) => {
    const { data } = props ?? {};

    return pauseSubscription(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: PauseSubscriptionBody },
    TContext
  >;
};

export type PauseSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof pauseSubscription>>
>;
export type PauseSubscriptionMutationBody = PauseSubscriptionBody;
export type PauseSubscriptionMutationError = AxiosError<void>;

/**
 * @summary Pause a subscription
 */
export const usePauseSubscription = <
  TData = Awaited<ReturnType<typeof pauseSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: PauseSubscriptionBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { data: PauseSubscriptionBody },
  TContext
> => {
  const mutationOptions = getPauseSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Resume a subscription. Subscription can be resumed only if it's paused.

 * @summary Resume a subscription
 */
export const resumeSubscription = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`/subscription/resume`, undefined, options);
};

export const getResumeSubscriptionMutationOptions = <
  TData = Awaited<ReturnType<typeof resumeSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['resumeSubscription'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resumeSubscription>>,
    void
  > = () => {
    return resumeSubscription(axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    void,
    TContext
  >;
};

export type ResumeSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof resumeSubscription>>
>;

export type ResumeSubscriptionMutationError = AxiosError<void>;

/**
 * @summary Resume a subscription
 */
export const useResumeSubscription = <
  TData = Awaited<ReturnType<typeof resumeSubscription>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getResumeSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get subscriptions
 * @summary Get subscriptions
 */
export const getSubscriptions = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Subscription>> => {
  return axios.get(`/subscription`, options);
};

export const getGetSubscriptionsQueryKey = () => {
  return [`/subscription`] as const;
};

export const getGetSubscriptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubscriptions>>,
  TError = AxiosError<void>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptions>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubscriptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubscriptions>>
  > = ({ signal }) => getSubscriptions({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSubscriptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubscriptions>>
>;
export type GetSubscriptionsQueryError = AxiosError<void>;

/**
 * @summary Get subscriptions
 */

export function useGetSubscriptions<
  TData = Awaited<ReturnType<typeof getSubscriptions>>,
  TError = AxiosError<void>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptions>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSubscriptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns all tags ordered by name.
 * @summary List all tags
 */
export const getTags = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Tag[]>> => {
  return axios.get(`/notes/tags`, options);
};

export const getGetTagsQueryKey = () => {
  return [`/notes/tags`] as const;
};

export const getGetTagsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTags>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({
    signal,
  }) => getTags({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTags>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTags>>
>;
export type GetTagsQueryError = AxiosError<unknown>;

/**
 * @summary List all tags
 */

export function useGetTags<
  TData = Awaited<ReturnType<typeof getTags>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTagsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new tag
 * @summary Create a tag
 */
export const createTag = (
  tagBase: TagBase,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Tag>> => {
  return axios.post(`/notes/tags`, tagBase, options);
};

export const getCreateTagMutationOptions = <
  TData = Awaited<ReturnType<typeof createTag>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TagBase }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['createTag'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTag>>,
    { data: TagBase }
  > = (props) => {
    const { data } = props ?? {};

    return createTag(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: TagBase },
    TContext
  >;
};

export type CreateTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTag>>
>;
export type CreateTagMutationBody = TagBase;
export type CreateTagMutationError = AxiosError<unknown>;

/**
 * @summary Create a tag
 */
export const useCreateTag = <
  TData = Awaited<ReturnType<typeof createTag>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TagBase }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, { data: TagBase }, TContext> => {
  const mutationOptions = getCreateTagMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update a tag
 * @summary Update a tag
 */
export const updateTag = (
  id: number,
  tagBase: TagBase,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Tag>> => {
  return axios.put(`/notes/tags/${id}`, tagBase, options);
};

export const getUpdateTagMutationOptions = <
  TData = Awaited<ReturnType<typeof updateTag>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: number; data: TagBase },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['updateTag'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTag>>,
    { id: number; data: TagBase }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateTag(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: number; data: TagBase },
    TContext
  >;
};

export type UpdateTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTag>>
>;
export type UpdateTagMutationBody = TagBase;
export type UpdateTagMutationError = AxiosError<void>;

/**
 * @summary Update a tag
 */
export const useUpdateTag = <
  TData = Awaited<ReturnType<typeof updateTag>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: number; data: TagBase },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { id: number; data: TagBase },
  TContext
> => {
  const mutationOptions = getUpdateTagMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get a tag
 * @summary Get a tag
 */
export const getTag = (
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Tag>> => {
  return axios.get(`/notes/tags/${id}`, options);
};

export const getGetTagQueryKey = (id: number) => {
  return [`/notes/tags/${id}`] as const;
};

export const getGetTagQueryOptions = <
  TData = Awaited<ReturnType<typeof getTag>>,
  TError = AxiosError<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTag>>> = ({
    signal,
  }) => getTag(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetTagQueryResult = NonNullable<Awaited<ReturnType<typeof getTag>>>;
export type GetTagQueryError = AxiosError<void>;

/**
 * @summary Get a tag
 */

export function useGetTag<
  TData = Awaited<ReturnType<typeof getTag>>,
  TError = AxiosError<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTagQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a tag
 * @summary Delete a tag
 */
export const deleteTag = (
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/notes/tags/${id}`, options);
};

export const getDeleteTagMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteTag>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: number }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['deleteTag'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTag>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return deleteTag(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: number },
    TContext
  >;
};

export type DeleteTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTag>>
>;

export type DeleteTagMutationError = AxiosError<void>;

/**
 * @summary Delete a tag
 */
export const useDeleteTag = <
  TData = Awaited<ReturnType<typeof deleteTag>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: number }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteTagMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns list of nodes that match given queries. Content of notes
is cutoff at 100 characters, to make the response smaller.

 * @summary List all notes
 */
export const getNotes = (
  params?: GetNotesParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Note[]>> => {
  return axios.get(`/notes`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetNotesQueryKey = (params?: GetNotesParams) => {
  return [`/notes`, ...(params ? [params] : [])] as const;
};

export const getGetNotesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotes>>,
  TError = AxiosError<unknown>,
>(
  params?: GetNotesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNotes>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotes>>> = ({
    signal,
  }) => getNotes(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNotesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotes>>
>;
export type GetNotesQueryError = AxiosError<unknown>;

/**
 * @summary List all notes
 */

export function useGetNotes<
  TData = Awaited<ReturnType<typeof getNotes>>,
  TError = AxiosError<unknown>,
>(
  params?: GetNotesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNotes>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNotesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new note
 * @summary Create a note
 */
export const createNote = (
  noteEdit: NoteEdit,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Note>> => {
  return axios.post(`/notes`, noteEdit, options);
};

export const getCreateNoteMutationOptions = <
  TData = Awaited<ReturnType<typeof createNote>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NoteEdit }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['createNote'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNote>>,
    { data: NoteEdit }
  > = (props) => {
    const { data } = props ?? {};

    return createNote(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: NoteEdit },
    TContext
  >;
};

export type CreateNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNote>>
>;
export type CreateNoteMutationBody = NoteEdit;
export type CreateNoteMutationError = AxiosError<unknown>;

/**
 * @summary Create a note
 */
export const useCreateNote = <
  TData = Awaited<ReturnType<typeof createNote>>,
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NoteEdit }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, { data: NoteEdit }, TContext> => {
  const mutationOptions = getCreateNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get a note
 * @summary Get a note
 */
export const getNote = (
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Note>> => {
  return axios.get(`/notes/${id}`, options);
};

export const getGetNoteQueryKey = (id: number) => {
  return [`/notes/${id}`] as const;
};

export const getGetNoteQueryOptions = <
  TData = Awaited<ReturnType<typeof getNote>>,
  TError = AxiosError<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getNote>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNoteQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNote>>> = ({
    signal,
  }) => getNote(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getNote>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetNoteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNote>>
>;
export type GetNoteQueryError = AxiosError<void>;

/**
 * @summary Get a note
 */

export function useGetNote<
  TData = Awaited<ReturnType<typeof getNote>>,
  TError = AxiosError<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getNote>>, TError, TData>;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNoteQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a note
 * @summary Update a note
 */
export const updateNote = (
  id: number,
  noteEdit: NoteEdit,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Note>> => {
  return axios.put(`/notes/${id}`, noteEdit, options);
};

export const getUpdateNoteMutationOptions = <
  TData = Awaited<ReturnType<typeof updateNote>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: number; data: NoteEdit },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['updateNote'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNote>>,
    { id: number; data: NoteEdit }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateNote(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: number; data: NoteEdit },
    TContext
  >;
};

export type UpdateNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNote>>
>;
export type UpdateNoteMutationBody = NoteEdit;
export type UpdateNoteMutationError = AxiosError<void>;

/**
 * @summary Update a note
 */
export const useUpdateNote = <
  TData = Awaited<ReturnType<typeof updateNote>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: number; data: NoteEdit },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  TData,
  TError,
  { id: number; data: NoteEdit },
  TContext
> => {
  const mutationOptions = getUpdateNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a note
 * @summary Delete a note
 */
export const deleteNote = (
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/notes/${id}`, options);
};

export const getDeleteNoteMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteNote>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: number }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationKey = ['deleteNote'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNote>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return deleteNote(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: number },
    TContext
  >;
};

export type DeleteNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNote>>
>;

export type DeleteNoteMutationError = AxiosError<void>;

/**
 * @summary Delete a note
 */
export const useDeleteNote = <
  TData = Awaited<ReturnType<typeof deleteNote>>,
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: number }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationResult<TData, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get referral info
 * @summary Get referral info
 */
export const getReferralInfo = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Referral>> => {
  return axios.get(`/referrals`, options);
};

export const getGetReferralInfoQueryKey = () => {
  return [`/referrals`] as const;
};

export const getGetReferralInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getReferralInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReferralInfo>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReferralInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReferralInfo>>> = ({
    signal,
  }) => getReferralInfo({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReferralInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetReferralInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReferralInfo>>
>;
export type GetReferralInfoQueryError = AxiosError<unknown>;

/**
 * @summary Get referral info
 */

export function useGetReferralInfo<
  TData = Awaited<ReturnType<typeof getReferralInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReferralInfo>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetReferralInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
